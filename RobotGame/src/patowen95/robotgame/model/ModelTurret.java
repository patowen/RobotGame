package patowen95.robotgame.model;
import java.nio.FloatBuffer;

import com.jogamp.opengl.GL;
import com.jogamp.opengl.GL2;

import com.jogamp.common.nio.Buffers;


/**
 * This class holds static methods that initialize and draw the turret head model,
 * used by EnemyTracking and EnemyTurret.
 * @author Michael Ekstrom
 * @author Patrick Owen
 */
public class ModelTurret
{
	//Model constants
	private static int stacks;
	private static int orbStacks;
	private static int slices;
	private static float length;
	private static float width;
	private static double phiCutoff;
	
	private static FloatBuffer xyzpts;
	private static FloatBuffer normals;
	
	/*
	 * The normals are generated by using the gradient vector at a given point on the ellipse or sphere.
	 */
	
	/**
	 * Initializes the turret model and allows all turret objects to use them.
	 * @param gl
	 */
	public static void init(GL2 gl)
	{
		/*
		 * ALGORITHM 3:
		 * Create float buffers to store vertices and normals (for lighting).
		 * The model itself is generated along the confines of a sphere, using spherical coordinates.
		 * After a certain phiCutoff value, the ellipse ends and the model starts adding points in a concave sphere to create the turret's muzzle.
		 */
		
		stacks = 20; orbStacks = 10;
		slices = 20; phiCutoff = 0.8;
		
		length = 1;//length of the ellipse
		width = 0.5f;//maximum width of the ellipse
		
		xyzpts = Buffers.newDirectFloatBuffer(6*(stacks+orbStacks)*(slices+1));
		normals = Buffers.newDirectFloatBuffer(6*(stacks+orbStacks)*(slices+1));
		
		//Outer shell
		for(int i=0; i<stacks; i++)
		{
			double phi = i*Math.PI*phiCutoff/stacks;
			
			for (int j=0; j<=slices; j++)
			{							
				double theta = j*2*Math.PI/slices;

				storePointOuter(phi+Math.PI*phiCutoff/stacks, theta, gl);
				storePointOuter(phi, theta, gl);
					
			}//end for loop: slices
		}//end for loop: stacks
		
		//Inner cavity
		double phiEnd = Math.PI*phiCutoff;
		double center = Math.cos(phiEnd) * length/2;
		double radius = Math.sin(phiEnd) * width/2;
		
		for (int i = orbStacks; i > 0; i--)
		{
			double phi = i*Math.PI/orbStacks/2;
			
			for (int j=0; j<=slices; j++)
			{							
				double theta = j*2*Math.PI/slices;

				storePointInner(phi-Math.PI/orbStacks/2, theta, center, radius, gl);
				storePointInner(phi, theta, center, radius, gl);
					
			}//end for loop: slices
		}
	}
	
	// Creates and stores a point for the turret. The normals are generated by using the gradient vector at a given point on the ellipse.
	private static void storePointOuter(double phi, double theta, GL2 gl)
	{
		float x = (float)Math.cos(phi) * (length/2);
		float radius = (float) Math.sin(phi) * (width/2);
		float y = (float)Math.sin(theta) * radius;
		float z = (float)Math.cos(theta) * radius;
		
		//Find the gradient vector.
		float nx = 2 * x / (length/2 * length/2);
		float ny = 2 * y / (width/2 * width/2);
		float nz = 2 * z / (width/2 * width/2);
		
		float n = (float)Math.sqrt(nx*nx + ny*ny + nz*nz);
		nx /= n; ny /= n; nz /= n;
		
		xyzpts.put(x);
		xyzpts.put(y);
		xyzpts.put(z);
		normals.put(nx);
		normals.put(ny);
		normals.put(nz);
	}//end storePoint
	
	// Creates and stores a point for the turret
	private static void storePointInner(double phi, double theta, double orbCenter, double orbRadius, GL gl)
	{
		float x = (float) (orbRadius*Math.cos(phi));
		float radius = (float) (orbRadius*Math.sin(phi));
		float y = (float)Math.sin(theta) * radius;
		float z = (float)Math.cos(theta) * radius;
		
		float nx = -x;
		float ny = -y;
		float nz = -z;
		
		x += orbCenter;
		
		float n = (float)Math.sqrt(nx*nx + ny*ny + nz*nz);
		nx /= n; ny /= n; nz /= n;
		
		xyzpts.put(x);
		xyzpts.put(y);
		xyzpts.put(z);
		normals.put(nx);
		normals.put(ny);
		normals.put(nz);
	}//end storePoint
	
	/**
	 * Draws the turret model facing in the standard direction (x-positive,
	 * z-positive is up)
	 * @param gl
	 */
	public static void draw(GL2 gl)
	{
		gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
		gl.glEnableClientState(GL2.GL_NORMAL_ARRAY);
		xyzpts.rewind();
		normals.rewind();
		gl.glVertexPointer(3, GL2.GL_FLOAT, 0, xyzpts);
		gl.glNormalPointer(GL2.GL_FLOAT, 0, normals);
		gl.glDrawArrays(GL2.GL_TRIANGLE_STRIP, 0, 2 * (stacks+orbStacks) * (slices+1));
		gl.glDisableClientState(GL2.GL_VERTEX_ARRAY);
		gl.glDisableClientState(GL2.GL_NORMAL_ARRAY);
	}
}
